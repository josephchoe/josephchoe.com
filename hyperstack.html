<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>The Hyperstack! | Joseph Choe</title>
    <meta name="description" content="I think about software development, writing, and many other things." />

        <link rel="alternate" type="application/atom+xml" title="Joseph Choe" href="/feed.xml">
    <link rel="stylesheet" type="text/css" href="/assets/css/style.css" />
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicons/favicon-16x16.png">
    <link rel="manifest" href="/assets/site.webmanifest">

    <meta name="author" content="Joseph Choe" />

  <meta property="og:url" content="https://josephchoe.com/hyperstack" />
  <meta property="og:title" content="The Hyperstack! | Joseph Choe" />
  <meta property="og:description" content="About a year ago I talked about developing my own personal technology.I wanted a codebase or foundation on which to build, well, literally anything.Something I could take with me wherever I went." />
  <meta property="og:image" content="https://josephchoe.com/assets/images/zurrey.jpg" />


  <meta property="og:type" content="article" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@josephchoe" />
  <meta name="twitter:creator" content="@josephchoe" />
  <meta name="twitter:title" content="The Hyperstack! | Joseph Choe" />
  <meta name="twitter:description" content="About a year ago I talked about developing my own personal technology.I wanted a codebase or foundation on which to build, well, literally anything.Something I could take with me wherever I went." />

  <meta name="twitter:image" content="https://josephchoe.com/assets/images/zurrey.jpg" />


  </head>

  <body>
    <header>
      <h1><a href="/" title="Joseph Choe">Joseph Choe</a></h1>
    </header>

    <main id="content">
      


<article>
  <div class="title">
    <h1>The Hyperstack!</h1>
  </div>
  <div class="post-date">
    <small>Fri May 3 2024</small>
  </div>
  <p>About a year ago I talked about developing my own <a href="/technology">personal technology</a>.
I wanted a codebase or foundation on which to build, well, literally anything.
Something I could take with me wherever I went.</p>

<p>In many ways, a year is both a long time, yet also not very much time at all.
There’s so much that can be done, so many directions to go.
I feel like I accomplished a great deal, yet only barely scratched the surface.</p>

<p>Here’s a very brief overview of how I write programs in C.
Honestly, I could discuss any of these things at length.</p>

<h2 id="development-environment">Development Environment</h2>

<p>My basic development environment is as follows:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- hyper
- os-obsd
- test-bench
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">hyper</code> library is my base layer, which houses basic primitives and data structures, including strings, queues, and more.
I’ll discuss this more down below.</p>

<p>The <code class="language-plaintext highlighter-rouge">os-obsd</code> library is basically a wrapper around operating system calls and library functions.
As you can see, it’s platform-specific, in my case, I’m developing primarily on OpenBSD, though I can foresee needing new libraries for other targets.</p>

<p>I do most of my experiments in the <code class="language-plaintext highlighter-rouge">test-bench</code> repository, usually to test out ideas or to figure out how a system call works.</p>

<p>I export the following environment variables:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">C_INCLUDE_PATH</span><span class="o">=</span><span class="nv">$HYPERSTACK_HOME</span>/hyper/src
<span class="nb">export </span><span class="nv">C_INCLUDE_PATH</span><span class="o">=</span><span class="nv">$C_INCLUDE_PATH</span>:<span class="nv">$HYPERSTACK_HOME</span>/os-obsd/src
<span class="nb">export </span><span class="nv">LIBRARY_PATH</span><span class="o">=</span><span class="nv">$HOME</span>/.local/lib
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$HOME</span>/.local/lib
</code></pre></div></div>

<p>This allows me to install the above libraries into those directories and dynamically link them from my projects.
I find this most helpful when writing a quick program that I want to run as a script with <code class="language-plaintext highlighter-rouge">rcc</code> (see below).</p>

<p>However, despite saying that, I don’t do much dynamic linking.
Instead, I include the <code class="language-plaintext highlighter-rouge">*.c</code> files in their own translation unit, say <code class="language-plaintext highlighter-rouge">hyper/lib.c</code> or <code class="language-plaintext highlighter-rouge">os/lib.c</code>, in whatever project I’m working on.
I’m bringing in specific modules I need, rather than linking against the entire library.</p>

<p>I also have a specific naming scheme for other libraries:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- nio-<span class="k">*</span>
- tio-<span class="k">*</span>
- vio-<span class="k">*</span>
</code></pre></div></div>

<p>Network I/O, or <code class="language-plaintext highlighter-rouge">nio-*</code>, is used for servers listening on TCP or UNIX sockets.
I use <code class="language-plaintext highlighter-rouge">tio-*</code> for terminal I/O, and <code class="language-plaintext highlighter-rouge">vio-*</code> for video or viewport I/O, such as when interfacing with an X11 server.</p>

<p>This can, of course, be extended to other sorts of libraries, though I haven’t yet written very many.</p>

<h2 id="base-layer">Base Layer</h2>

<p>Many people say that the C Standard Library is not very good, which is why most people build their own abstractions.
I suppose I agree with them, because I’ve written my own as well.</p>

<p>I have types like <code class="language-plaintext highlighter-rouge">i32</code> defined for signed integers and <code class="language-plaintext highlighter-rouge">u32</code> for unsigned.
There are other <code class="language-plaintext highlighter-rouge">typedefs</code> here, but I won’t go into all of them.
Mostly I use these as semantic indicators, like when I need to indicate that a variable indicates a pointer offset or a size integer or whatever else.</p>

<p>I also have macros defined for simple queues and lists.
I may need to define some for trees or hash tables, though I haven’t found the need for this yet.</p>

<p>To manage memory, I primarily use arena allocators (or linear or bump allocators).
I then build off these arenas and build other types of memory management, like freelists or pool allocators.</p>

<p>The <code class="language-plaintext highlighter-rouge">hyper</code> library doesn’t actually make any function calls to <code class="language-plaintext highlighter-rouge">malloc(3)</code> or <code class="language-plaintext highlighter-rouge">mmap(2)</code>.
Instead, it accepts pointers to memory that was reserved and committed in <code class="language-plaintext highlighter-rouge">os-obsd</code>.</p>

<p>I never reallocate memory or request larger chunks of memory in the middle of a program.
Instead, I reserve a huge chunk of memory, enough for whatever my program needs, <em>at the beginning of runtime</em>, and recycle this memory over the lifetime of the program.</p>

<p>So much of low-level programming seems to be about manipulating bytes or strings of bytes.
As such, I have data structures for string views, which allows me to indicate how large a string is along with a character pointer.
I only <code class="language-plaintext highlighter-rouge">nil</code>-terminate these strings when I need to interface with C library functions.</p>

<p>Instead of <code class="language-plaintext highlighter-rouge">printf(3)</code>, I use I/O buffers that are appended to.
I have most data types covered, including appending integers, signed or unsigned, strings, or whatever else.
Each buffer has its own size and associated <code class="language-plaintext highlighter-rouge">flush</code> function, which allows calls to I/O to be chunked or amortized.
This can also be called directly, so I can control when the buffer is flushed.</p>

<p>So instead of:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="s">"Hello, %s!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</code></pre></div></div>

<p>It looks like this:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">io8_append_c8a</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"Hello, "</span><span class="p">);</span>
<span class="n">io8_append</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="n">io8_append_c8</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="sc">'!'</span><span class="p">);</span>
<span class="n">io8_newline</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="n">io8_flush</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
</code></pre></div></div>

<p>It’s a bit more verbose, but I enjoy the control it affords.</p>

<p>I can also use these I/O buffers without a flush function, in order to build strings.
I append to these and then just output a string view, whose memory I can use wherever I want.</p>

<p>I find that this works well.</p>

<h2 id="build-system">Build System</h2>

<p>I use a non-traditional build system.
I considered using <code class="language-plaintext highlighter-rouge">make(1)</code>, but I didn’t enjoy maintaining a series of more and more complex Makefiles.</p>

<p>Instead I use <code class="language-plaintext highlighter-rouge">redo</code>, a hypothetical build system designed by Daniel J. Bernstein, though he never published an implementation.
Instead, several others have taken it upon themselves to write their own implementations, each one somewhat different from each other.</p>

<p>It uses a series of shell scripts to handle recursive builds.
This seems easier, but it can be a bit difficult to reason about the dependencies, at least in my mind.</p>

<p>I’m not really happy with how my build system works right now, so I will probably revisit this in the future.</p>

<h2 id="projects">Projects</h2>

<p>Here are a few projects I’ve built in the past year or so.
They’re mostly simple one-off projects to help me understand different system calls, library functions, and so forth.
However, they’ve been extremely helpful learning experiences!</p>

<h4 id="rcc">rcc</h4>

<p>I like to call this project the <strong>Run C Compiler</strong> program.
I wanted a way to run scripts without invoking a compiler, i.e. <code class="language-plaintext highlighter-rouge">cc test.c &amp;&amp; ./a.out</code>.
So I wrote a program that would compile a <code class="language-plaintext highlighter-rouge">*.c</code> file and run the program with whatever arguments I passed in.
Similar to an interpreted language, haha.</p>

<p>I have it installed as <code class="language-plaintext highlighter-rouge">c</code> under <code class="language-plaintext highlighter-rouge">$HOME/.local/bin</code>.
I just invoke the following:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c test.c <span class="o">[</span>optional args]
</code></pre></div></div>

<p>And since my <code class="language-plaintext highlighter-rouge">C_INCLUDE_PATH</code>, <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code>, and <code class="language-plaintext highlighter-rouge">LIBRARY_PATH</code> environment variables are already exported, I can use my own libraries when running thse “C scripts”.</p>

<h4 id="xio-wmstatus">xio-wmstatus</h4>

<p>A simpler replacement for <code class="language-plaintext highlighter-rouge">slstatus</code>.
It writes fuzzy time into the X11 root window’s <code class="language-plaintext highlighter-rouge">WM_NAME</code>, which works well with my tiling window manager.
It also reads from <code class="language-plaintext highlighter-rouge">apm(4)</code>, so I can tell how much battery is left or whether the battery is plugged in when the program is running on my laptops.</p>

<p>Here’s what it usually outputs into <code class="language-plaintext highlighter-rouge">WM_NAME</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WM_NAME(STRING) = "Wednesday May 3rd, ten past six"
</code></pre></div></div>

<h4 id="xio-plug">xio-plug</h4>

<p>I needed a way to detect when a monitor was plugged on or off of my machine.
This program waits for those events from the X11 server and runs a script, passing those displays and whether they’re <code class="language-plaintext highlighter-rouge">connected</code> or <code class="language-plaintext highlighter-rouge">disconnected</code> as arguments</p>

<h4 id="nio-stream">nio-stream</h4>

<p>This is my base library for running TCP servers, though it could probably be adapted to listen on UNIX sockets as well.
Instead of <code class="language-plaintext highlighter-rouge">pthreads(3)</code>, it uses <code class="language-plaintext highlighter-rouge">kqueue(2)</code> in order to multiplex non-blocking I/O.
I’ve used this to build HTTP servers as well as simple pastebin upload servers, similar to <a href="https://termbin.com">termbin.com</a>.</p>

<h4 id="nio-http">nio-http</h4>

<p>Data structures for parsing HTTP messages from a string of bytes.
Obviously, it’s not as feature complete as the actual protocol, but I don’t need it to be.
I basically use these servers to pass messages back and forth, while a public endpoint, in some other language like Ruby, serves as a router to these other HTTP servers.
As I’m in control of these servers, and they aren’t public-facing, I can basically get away with a less robust implementation.</p>

<h2 id="caveats">Caveats</h2>

<p>Obviously, this is how <em>I</em> do things.</p>

<p>I’m not really aiming to interface with other people or work with their code.
Nor am I looking to make this code public.</p>

<p>I’m mostly interested in tinkering around on my own, forming a foundation of solid code off which I can build my own applications, whatever those may be.</p>

<p>Even though I’m using C99, I kind of think of this as my own dialect of C.</p>

<h2 id="todo">TODO</h2>

<p>A few things I’d like to do in the future are:</p>

<ul>
  <li>My own build system!</li>
  <li>Text editor</li>
  <li>Graphics/animation library</li>
  <li>Figure out audio, i.e. <code class="language-plaintext highlighter-rouge">sndio(7)</code></li>
  <li>Build a more complex graphical application with <code class="language-plaintext highlighter-rouge">libxcb</code></li>
  <li>Work with a different platform, i.e. <code class="language-plaintext highlighter-rouge">os-linux</code></li>
  <li>Move away from <code class="language-plaintext highlighter-rouge">libc</code></li>
  <li>And one day, build a video game!!</li>
</ul>

  <footer>
    <hr />
    
<div class="page-navigation">

  <a class="previous" href="/cmixer">&laquo; Bending cmixer to my will!</a>



</div>


    <div class="no-comments">
  <a href="/no-comments">No comments.</a>
</div>

    <div class="copyright">
  &copy; 2024 <a href="https://josephchoe.com">Joseph Choe</a>.
</div>

  </footer>
</article>

    </main>

    <footer>
    </footer>
  </body>
</html>
